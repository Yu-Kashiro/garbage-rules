# 技術選定理由書

このドキュメントでは、Garbage Rules（ゴミ分別ルール検索アプリケーション）で採用した技術について、選定理由を説明します。

---

## フレームワーク・言語

### Next.js 16 + React 19

**選定理由:**

1. **App Router によるサーバーコンポーネント活用**
   - サーバーサイドでのデータフェッチにより、初期表示が高速
   - クライアントバンドルサイズの削減
   - SEO に有利な SSR/SSG をデフォルトでサポート

2. **フルスタック開発の効率化**
   - API Routes により、フロントエンドとバックエンドを同一プロジェクトで管理
   - 別途バックエンドサーバーを構築する必要がない
   - デプロイの簡素化（Vercel などへのワンクリックデプロイ）

3. **React 19 の最新機能**
   - Server Actions によるフォーム処理の簡素化
   - Suspense/Streaming によるユーザー体験の向上

**代替案との比較:**
- **Remix**: 同様にフルスタック対応だが、エコシステムの成熟度で Next.js を選択
- **SPA (Vite + React)**: SEO 要件とサーバーサイド機能の必要性から不採用

---

### TypeScript

**選定理由:**

1. **型安全性**
   - コンパイル時にエラーを検出し、実行時エラーを減少
   - IDE による補完・リファクタリング支援の向上

2. **フルスタックでの型共有**
   - データベーススキーマから API レスポンスまで一貫した型定義
   - Drizzle ORM + Zod との統合による End-to-End の型安全性

3. **ドキュメントとしての役割**
   - 型定義がそのまま API 仕様のドキュメントとして機能
   - チーム開発時のコミュニケーションコスト削減

---

## UI / スタイリング

### Tailwind CSS 4

**選定理由:**

1. **ユーティリティファーストによる高速な開発**
   - CSS ファイルを別途管理する必要がない
   - コンポーネント内でスタイルが完結し、コードの見通しが良い

2. **一貫したデザインシステム**
   - spacing、color、typography などが標準化されている
   - デザイントークンとして統一されたルールを適用可能

3. **バンドルサイズの最適化**
   - 使用したクラスのみが本番ビルドに含まれる
   - CSS の肥大化を自動的に防止

**代替案との比較:**
- **CSS Modules**: 名前空間の衝突は防げるが、ユーティリティの利便性がない
- **styled-components**: ランタイムコストがあり、SSR との相性に課題

---

### Radix UI + shadcn/ui

**選定理由:**

1. **アクセシビリティの担保**
   - Radix UI は WAI-ARIA に準拠したヘッドレス UI ライブラリ
   - キーボードナビゲーション、スクリーンリーダー対応が標準
   - 自治体向けサービスとしてアクセシビリティは重要

2. **高いカスタマイズ性**
   - shadcn/ui はコードをプロジェクトにコピーする方式
   - ライブラリのバージョンに依存せず、自由にカスタマイズ可能
   - Tailwind CSS との親和性が高い

3. **保守性**
   - コンポーネントのソースコードが手元にあるため、デバッグが容易
   - ブラックボックスがなく、挙動を完全に把握できる

**代替案との比較:**
- **MUI (Material UI)**: デザインの自由度が低く、Material Design に縛られる
- **Chakra UI**: Tailwind CSS との併用が難しい

---

## データベース / ORM

### Turso (libSQL)

**選定理由:**

1. **エッジ対応**
   - グローバルに分散されたリードレプリカ
   - ユーザーに近い場所からのデータ提供が可能

2. **SQLite ベースの信頼性**
   - 実績のある SQLite をベースにしているため、信頼性が高い
   - シンプルなデータモデルに最適

3. **低コスト**
   - 無料枠が十分に大きい
   - スタートアップや個人プロジェクトに適した価格体系

4. **開発体験**
   - ローカル開発時は SQLite ファイルで動作可能
   - 本番環境との差異が小さい

**代替案との比較:**
- **PostgreSQL (Supabase/Neon)**: 高機能だが、本プロジェクトの規模では過剰
- **PlanetScale**: MySQL ベースで良い選択肢だが、無料枠の制限

---

### Drizzle ORM

**選定理由:**

1. **TypeScript ファースト**
   - スキーマ定義から型が自動生成される
   - SQL に近い直感的な API

2. **軽量・高速**
   - ランタイムが小さく、パフォーマンスに優れる
   - Prisma と比較してバンドルサイズが大幅に小さい

3. **マイグレーション管理**
   - `drizzle-kit` による宣言的なマイグレーション
   - スキーマの差分を自動検出

4. **Zod との統合**
   - `drizzle-zod` によるバリデーションスキーマの自動生成
   - フォームバリデーションとデータベーススキーマの一貫性

**代替案との比較:**
- **Prisma**: 人気だが、ランタイムが大きく、エッジ環境での制約あり
- **Kysely**: 型安全だが、マイグレーションツールが別途必要

---

## 検索機能

### Fuse.js

**選定理由:**

1. **ファジー検索（曖昧検索）**
   - ユーザーの入力ミスや表記揺れに対応
   - 「ペットボトル」「ぺっとぼとる」「PETボトル」などを柔軟にマッチ

2. **クライアントサイド検索**
   - サーバーへのリクエスト不要で高速なレスポンス
   - オフラインでも動作可能

3. **日本語対応**
   - Unicode 正規化により、ひらがな・カタカナ・漢字を適切に処理

4. **軽量**
   - 外部サービスへの依存がない
   - ゴミ分別データ程度の規模なら十分なパフォーマンス

**代替案との比較:**
- **Algolia/Meilisearch**: 高機能だが、外部サービスへの依存とコスト
- **PostgreSQL 全文検索**: サーバーサイドでの処理が必要

---

## 認証

### better-auth

**選定理由:**

1. **シンプルさ**
   - 設定が少なく、素早く導入可能
   - ドキュメントがわかりやすい

2. **TypeScript ネイティブ**
   - 型定義が充実しており、開発体験が良い

3. **自己ホスト**
   - ユーザーデータを自分のデータベースで管理
   - プライバシーとデータ主権の確保

**代替案との比較:**
- **NextAuth.js (Auth.js)**: 歴史は長いが、v5 への移行期で API が不安定
- **Clerk/Auth0**: 外部サービスへの依存とコスト

---

## フォーム / バリデーション

### React Hook Form + Zod

**選定理由:**

1. **パフォーマンス**
   - 非制御コンポーネントベースで、不要な再レンダリングを回避
   - 大規模フォームでも軽快に動作

2. **スキーマベースのバリデーション**
   - Zod スキーマを定義するだけで、フォームバリデーションが完成
   - エラーメッセージの型安全な管理

3. **Server Actions との統合**
   - Next.js の Server Actions と組み合わせてシームレスに動作

**代替案との比較:**
- **Formik**: 制御コンポーネントベースでパフォーマンスに課題
- **独自実装**: 車輪の再発明になりがち

---

## テスト

### Playwright

**選定理由:**

1. **E2E テストの信頼性**
   - 実際のブラウザでテストを実行
   - ユーザーと同じ環境でのテストが可能

2. **クロスブラウザ対応**
   - Chromium, Firefox, WebKit を単一のコードでテスト
   - 本プロジェクトでは全3ブラウザでテストを実行

3. **優れた開発体験**
   - コードジェネレーター、デバッグツール、トレースビューア
   - 失敗時のスクリーンショット・動画記録

4. **認証済みテストのサポート**
   - `storageState` によるログイン状態の再利用
   - テスト実行時間の短縮

**代替案との比較:**
- **Cypress**: 人気だが、WebKit サポートがなく、並列実行に制限
- **Jest + Testing Library**: 単体テストには適するが、E2E には不十分

---

## 開発ツール

### pnpm

**選定理由:**

1. **高速なインストール**
   - コンテンツアドレス可能なストレージにより、重複パッケージを共有
   - 特に CI/CD での時間短縮効果が大きい

2. **ディスク効率**
   - ハードリンクにより、同じパッケージを複数プロジェクトで共有
   - node_modules の肥大化を防止

3. **厳格な依存関係管理**
   - 幽霊依存（phantom dependencies）を防止
   - 意図しないパッケージへのアクセスをブロック

**代替案との比較:**
- **npm**: 標準だが、速度とディスク効率で劣る
- **yarn**: 良い選択肢だが、pnpm のディスク効率には及ばない

---

### ESLint + Prettier

**選定理由:**

1. **コード品質の自動化**
   - ESLint によるバグの早期発見（未使用変数、型エラーなど）
   - Prettier による一貫したフォーマット

2. **チーム開発での統一**
   - コードスタイルの議論を排除
   - PR レビューで本質的な議論に集中

3. **Next.js との統合**
   - `eslint-config-next` による Next.js 固有のルール
   - Core Web Vitals に関するベストプラクティスの強制

---

## URL 状態管理

### nuqs

**選定理由:**

1. **URL とステートの同期**
   - 検索クエリやフィルターを URL に保持
   - ブックマーク可能、共有可能な検索結果

2. **Next.js App Router との統合**
   - Server Components と Client Components の両方で動作
   - URLSearchParams の型安全な管理

3. **シンプルな API**
   - useState と同じような感覚で使用可能
   - 学習コストが低い

**代替案との比較:**
- **独自実装 (useSearchParams)**: ボイラープレートが多くなる
- **状態管理ライブラリ (Zustand)**: URL との同期が手動になる

---

## まとめ

本プロジェクトの技術選定は、以下の方針に基づいています：

1. **TypeScript による型安全性の確保**: End-to-End で型を共有し、実行時エラーを最小化
2. **モダンなフルスタック開発**: Next.js の App Router を活用した効率的な開発
3. **ユーザー体験の重視**: 高速な初期表示、ファジー検索、アクセシビリティ対応
4. **保守性とカスタマイズ性**: shadcn/ui のような「自分のコード」として管理できるライブラリを優先
5. **低コスト・低依存**: 可能な限り外部サービスへの依存を減らし、セルフホスト可能な構成

これらの技術選定により、ゴミ分別という市民向けサービスに適した、高品質で保守しやすいアプリケーションを実現しています。
